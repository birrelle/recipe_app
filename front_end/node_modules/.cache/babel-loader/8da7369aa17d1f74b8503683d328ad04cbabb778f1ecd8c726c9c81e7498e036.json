{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheTimestampsModel } from './models/CacheTimestampsModel.js';\nimport './_version.js';\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof workbox-expiration\n */\nclass CacheExpiration {\n  /**\n   * To construct a new CacheExpiration instance you must provide at least\n   * one of the `config` properties.\n   *\n   * @param {string} cacheName Name of the cache to apply restrictions to.\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n   * that will be used when calling `delete()` on the cache.\n   */\n  constructor(cacheName, config = {}) {\n    this._isRunning = false;\n    this._rerunRequested = false;\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'constructor',\n        paramName: 'cacheName'\n      });\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor'\n        });\n      }\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries'\n        });\n      }\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds'\n        });\n      }\n    }\n    this._maxEntries = config.maxEntries;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._matchOptions = config.matchOptions;\n    this._cacheName = cacheName;\n    this._timestampModel = new CacheTimestampsModel(cacheName);\n  }\n  /**\n   * Expires entries for the given cache and given criteria.\n   */\n  async expireEntries() {\n    if (this._isRunning) {\n      this._rerunRequested = true;\n      return;\n    }\n    this._isRunning = true;\n    const minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1000 : 0;\n    const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\n    // Delete URLs from the cache\n    const cache = await self.caches.open(this._cacheName);\n    for (const url of urlsExpired) {\n      await cache.delete(url, this._matchOptions);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      if (urlsExpired.length > 0) {\n        logger.groupCollapsed(`Expired ${urlsExpired.length} ` + `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` + `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` + `'${this._cacheName}' cache.`);\n        logger.log(`Expired the following ${urlsExpired.length === 1 ? 'URL' : 'URLs'}:`);\n        urlsExpired.forEach(url => logger.log(`    ${url}`));\n        logger.groupEnd();\n      } else {\n        logger.debug(`Cache expiration ran and found no entries to remove.`);\n      }\n    }\n    this._isRunning = false;\n    if (this._rerunRequested) {\n      this._rerunRequested = false;\n      dontWaitFor(this.expireEntries());\n    }\n  }\n  /**\n   * Update the timestamp for the given URL. This ensures the when\n   * removing entries based on maximum entries, most recently used\n   * is accurate or when expiring, the timestamp is up-to-date.\n   *\n   * @param {string} url\n   */\n  async updateTimestamp(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(url, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'updateTimestamp',\n        paramName: 'url'\n      });\n    }\n    await this._timestampModel.setTimestamp(url, Date.now());\n  }\n  /**\n   * Can be used to check if a URL has expired or not before it's used.\n   *\n   * This requires a look up from IndexedDB, so can be slow.\n   *\n   * Note: This method will not remove the cached entry, call\n   * `expireEntries()` to remove indexedDB and Cache entries.\n   *\n   * @param {string} url\n   * @return {boolean}\n   */\n  async isURLExpired(url) {\n    if (!this._maxAgeSeconds) {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new WorkboxError(`expired-test-without-max-age`, {\n          methodName: 'isURLExpired',\n          paramName: 'maxAgeSeconds'\n        });\n      }\n      return false;\n    } else {\n      const timestamp = await this._timestampModel.getTimestamp(url);\n      const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n      return timestamp !== undefined ? timestamp < expireOlderThan : true;\n    }\n  }\n  /**\n   * Removes the IndexedDB object store used to keep track of cache expiration\n   * metadata.\n   */\n  async delete() {\n    // Make sure we don't attempt another rerun if we're called in the middle of\n    // a cache expiration.\n    this._rerunRequested = false;\n    await this._timestampModel.expireEntries(Infinity); // Expires all.\n  }\n}\nexport { CacheExpiration };","map":{"version":3,"names":["assert","dontWaitFor","logger","WorkboxError","CacheTimestampsModel","CacheExpiration","constructor","cacheName","config","_isRunning","_rerunRequested","process","env","NODE_ENV","isType","moduleName","className","funcName","paramName","maxEntries","maxAgeSeconds","_maxEntries","_maxAgeSeconds","_matchOptions","matchOptions","_cacheName","_timestampModel","expireEntries","minTimestamp","Date","now","urlsExpired","cache","self","caches","open","url","delete","length","groupCollapsed","log","forEach","groupEnd","debug","updateTimestamp","setTimestamp","isURLExpired","methodName","timestamp","getTimestamp","expireOlderThan","undefined","Infinity"],"sources":["/Users/emilybirrell/Desktop/recipe_app/my-recipe-app/node_modules/workbox-expiration/CacheExpiration.js"],"sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheTimestampsModel } from './models/CacheTimestampsModel.js';\nimport './_version.js';\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof workbox-expiration\n */\nclass CacheExpiration {\n    /**\n     * To construct a new CacheExpiration instance you must provide at least\n     * one of the `config` properties.\n     *\n     * @param {string} cacheName Name of the cache to apply restrictions to.\n     * @param {Object} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n     * that will be used when calling `delete()` on the cache.\n     */\n    constructor(cacheName, config = {}) {\n        this._isRunning = false;\n        this._rerunRequested = false;\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(cacheName, 'string', {\n                moduleName: 'workbox-expiration',\n                className: 'CacheExpiration',\n                funcName: 'constructor',\n                paramName: 'cacheName',\n            });\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new WorkboxError('max-entries-or-age-required', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                });\n            }\n            if (config.maxEntries) {\n                assert.isType(config.maxEntries, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                    paramName: 'config.maxEntries',\n                });\n            }\n            if (config.maxAgeSeconds) {\n                assert.isType(config.maxAgeSeconds, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                    paramName: 'config.maxAgeSeconds',\n                });\n            }\n        }\n        this._maxEntries = config.maxEntries;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._matchOptions = config.matchOptions;\n        this._cacheName = cacheName;\n        this._timestampModel = new CacheTimestampsModel(cacheName);\n    }\n    /**\n     * Expires entries for the given cache and given criteria.\n     */\n    async expireEntries() {\n        if (this._isRunning) {\n            this._rerunRequested = true;\n            return;\n        }\n        this._isRunning = true;\n        const minTimestamp = this._maxAgeSeconds\n            ? Date.now() - this._maxAgeSeconds * 1000\n            : 0;\n        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\n        // Delete URLs from the cache\n        const cache = await self.caches.open(this._cacheName);\n        for (const url of urlsExpired) {\n            await cache.delete(url, this._matchOptions);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (urlsExpired.length > 0) {\n                logger.groupCollapsed(`Expired ${urlsExpired.length} ` +\n                    `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\n                    `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\n                    `'${this._cacheName}' cache.`);\n                logger.log(`Expired the following ${urlsExpired.length === 1 ? 'URL' : 'URLs'}:`);\n                urlsExpired.forEach((url) => logger.log(`    ${url}`));\n                logger.groupEnd();\n            }\n            else {\n                logger.debug(`Cache expiration ran and found no entries to remove.`);\n            }\n        }\n        this._isRunning = false;\n        if (this._rerunRequested) {\n            this._rerunRequested = false;\n            dontWaitFor(this.expireEntries());\n        }\n    }\n    /**\n     * Update the timestamp for the given URL. This ensures the when\n     * removing entries based on maximum entries, most recently used\n     * is accurate or when expiring, the timestamp is up-to-date.\n     *\n     * @param {string} url\n     */\n    async updateTimestamp(url) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(url, 'string', {\n                moduleName: 'workbox-expiration',\n                className: 'CacheExpiration',\n                funcName: 'updateTimestamp',\n                paramName: 'url',\n            });\n        }\n        await this._timestampModel.setTimestamp(url, Date.now());\n    }\n    /**\n     * Can be used to check if a URL has expired or not before it's used.\n     *\n     * This requires a look up from IndexedDB, so can be slow.\n     *\n     * Note: This method will not remove the cached entry, call\n     * `expireEntries()` to remove indexedDB and Cache entries.\n     *\n     * @param {string} url\n     * @return {boolean}\n     */\n    async isURLExpired(url) {\n        if (!this._maxAgeSeconds) {\n            if (process.env.NODE_ENV !== 'production') {\n                throw new WorkboxError(`expired-test-without-max-age`, {\n                    methodName: 'isURLExpired',\n                    paramName: 'maxAgeSeconds',\n                });\n            }\n            return false;\n        }\n        else {\n            const timestamp = await this._timestampModel.getTimestamp(url);\n            const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n            return timestamp !== undefined ? timestamp < expireOlderThan : true;\n        }\n    }\n    /**\n     * Removes the IndexedDB object store used to keep track of cache expiration\n     * metadata.\n     */\n    async delete() {\n        // Make sure we don't attempt another rerun if we're called in the middle of\n        // a cache expiration.\n        this._rerunRequested = false;\n        await this._timestampModel.expireEntries(Infinity); // Expires all.\n    }\n}\nexport { CacheExpiration };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}